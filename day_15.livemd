<!-- livebook:{"persist_outputs":true} -->

# Dia 15: Chiton

## Leitura do arquivo de entrada

Mais uma vez temos um grafo, mas desta vez com pesos.

Vamos armazená-lo em um mapa, na estrutura `%{{x, y} => peso}`.

```elixir
input_matrix =
  "data/day_15_input.txt"
  |> File.read!()
  |> String.split("\n", trim: true)
  |> Enum.map(fn line -> String.split(line, "", trim: true) end)
  |> Enum.map(fn line -> Enum.map(line, &String.to_integer/1) end)

weight_map =
  for {row_weights, row} <- Enum.with_index(input_matrix),
      {weight, column} <- Enum.with_index(row_weights),
      into: %{},
      do: {{column, row}, weight}
```

```output
%{
  {76, 13} => 7,
  {37, 47} => 1,
  {65, 63} => 7,
  {38, 2} => 1,
  {1, 26} => 2,
  {83, 76} => 2,
  {32, 15} => 6,
  {89, 14} => 2,
  {35, 30} => 6,
  {37, 53} => 1,
  {4, 5} => 7,
  {8, 50} => 2,
  {78, 98} => 1,
  {95, 56} => 7,
  {74, 12} => 1,
  {11, 39} => 6,
  {65, 43} => 8,
  {22, 38} => 4,
  {14, 86} => 6,
  {20, 41} => 2,
  {29, 25} => 8,
  {86, 10} => 2,
  {83, 36} => 3,
  {29, 26} => 2,
  {47, 27} => 1,
  {4, 81} => 4,
  {31, 42} => 3,
  {9, 34} => 4,
  {90, 0} => 2,
  {67, 98} => 1,
  {13, 85} => 8,
  {63, 81} => 1,
  {82, 60} => 8,
  {47, 38} => 5,
  {15, 92} => 1,
  {58, 58} => 2,
  {20, 3} => 1,
  {61, 95} => 1,
  {23, 67} => 8,
  {78, 75} => 1,
  {79, 17} => 7,
  {75, 0} => 6,
  {16, 73} => 7,
  {76, 2} => 8,
  {58, 84} => 2,
  {58, 33} => 4,
  {47, 44} => 2,
  {54, 31} => 1,
  {13, ...} => 4,
  {...} => 4,
  ...
}
```

## Identificando o  menor caminho

Para identificar o menor caminho de maneira eficiente, podemos utilizar um algoritmo guloso.

Imagine a entrada:

```
1 2 3
3 4 1
1 1 5
```

Começamos identificando os vizinhos do ponto inicial e consideramos que os mesmos foram visitados. Mapeamos estes pontos como **pontos da margem**:

```
1   2 | 3
    -
3 | 4   1
-
1   1   5
```

Os pontos do lado esquerdo da margem já tiveram seus pesos calculados. Na próxima etapa, consideramos os vizinhos da borda e somamos seus pesos ao peso do último nó:

```
1   2   5 |
        -   
3   6 | 1
    -
4 | 1   5
```

Ah! Caso haja dois caminhos até o destino final, selecionamos o de menor peso.

```elixir
defmodule GraphNavigator do
  def start(weight_map, start_node \\ {0, 0}) do
    nodes_to_check = get_unvisited_neighbors(weight_map, %{}, start_node)

    visited_nodes =
      nodes_to_check
      |> Map.new()
      |> Map.put(start_node, 0)

    explore_graph(weight_map, visited_nodes, nodes_to_check)
  end

  defp explore_graph(_weight_map, visited_nodes, _nodes_to_check = []), do: visited_nodes

  defp explore_graph(weight_map, visited_nodes, border_nodes) do
    node_to_visit =
      border_nodes
      |> Enum.flat_map(fn {coords, _value} ->
        get_unvisited_neighbors(weight_map, visited_nodes, coords)
      end)
      |> Enum.sort()
      |> Enum.dedup_by(fn {coord, _weight} -> coord end)
      |> Enum.min_by(fn {_coord, weight} -> weight end)

    new_visited_nodes =
      visited_nodes
      |> Map.put(elem(node_to_visit, 0), elem(node_to_visit, 1))

    updater = Enum.count(new_visited_nodes)

    if rem(updater, 1000) == 0 do
      IO.puts()
    end

    new_border_nodes =
      [node_to_visit | border_nodes]
      |> Enum.filter(fn {coords, _} ->
        get_unvisited_neighbors(weight_map, new_visited_nodes, coords) != []
      end)

    explore_graph(weight_map, new_visited_nodes, new_border_nodes)
  end

  defp get_unvisited_neighbors(weight_map, visited_nodes, node) do
    current_weight = Map.get(visited_nodes, node, 0)

    get_neighbors(weight_map, node)
    |> Enum.filter(fn {_coord, result} -> result != nil end)
    |> Enum.filter(fn {coord, _result} -> not Map.has_key?(visited_nodes, coord) end)
    |> Enum.map(fn {coords, weight} -> {coords, weight + current_weight} end)
  end

  defp get_neighbors(weight_map, _node = {node_x, node_y}) do
    [
      {{node_x, node_y + 1}, Map.get(weight_map, {node_x, node_y + 1})},
      {{node_x + 1, node_y}, Map.get(weight_map, {node_x + 1, node_y})}
    ]
  end
end

GraphNavigator.start(weight_map)
|> Enum.sort()
|> Enum.at(-1)
```

```output
1000
2000
3000
4000
5000
6000
7000
8000
9000
10000
```

```output
{{99, 99}, 363}
```

## Estrela 30: A caverna gigante

```elixir
defmodule BigCaveExplorer do
  def find_shortest
end
```

```output
%{
  {150, 137} => 5,
  {79, 254} => 3,
  {1, 246} => 3,
  {165, 437} => 3,
  {92, 439} => 1,
  {487, 278} => 7,
  {334, 232} => 7,
  {440, 15} => 6,
  {392, 198} => 7,
  {18, 103} => 2,
  {469, 44} => 6,
  {131, 170} => 5,
  {440, 452} => 9,
  {355, 320} => 8,
  {401, 346} => 8,
  {125, 238} => 4,
  {76, 13} => 7,
  {138, 278} => 4,
  {86, 451} => 7,
  {215, 277} => 1,
  {297, 142} => 5,
  {310, 481} => 8,
  {373, 444} => 4,
  {436, 103} => 4,
  {142, 180} => 6,
  {14, 164} => 2,
  {377, 222} => 1,
  {10, 433} => 8,
  {457, 178} => 1,
  {409, 196} => 9,
  {365, 479} => 7,
  {423, 255} => 6,
  {30, 322} => 4,
  {198, 146} => 4,
  {24, 389} => 7,
  {463, 186} => 8,
  {61, 121} => 4,
  {54, 331} => 4,
  {417, 25} => 5,
  {248, 394} => 4,
  {112, 138} => 4,
  {60, 220} => 8,
  {388, 228} => 9,
  {439, 387} => 8,
  {37, 453} => 5,
  {320, 461} => 8,
  {482, 11} => 7,
  {461, 118} => 8,
  {253, ...} => 4,
  {...} => 3,
  ...
}
```
